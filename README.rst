The VRFT Technique
==================

**V**\ irtual **R**\ eference **F**\ eedback **T**\ uning is a data driven method to design a controller for an unknown plant based on input/ouput measurements. The method can be applied using a single set of input/output data generated by the plant without the need for specific experiments or model identifcation. 

The plant must be a linear SISO, dicrete time dynamical system. 

The ideal behaviour of the closed-loop system is described by a reference model :math:`M_R(z)`. The controller must be linearly dependant on the parameter vector (:math:`\theta`) such that: 

.. math::
    
    C(z; \theta) = \beta^T\theta^T

Where: 

* :math:`\beta = [\beta_1(z), \beta_2(z), ..., \beta_n(z)]^T` is a vector of linear transfer functions
* :math:`\theta = [\theta_1, \theta_2, ... \theta_n]^T` is the vector of parameters
  
The control algorithm attempts to minimise the following criterion: 

.. math:: 

    \begin{aligned}
        J_{MR}(\theta) &= \left| \left( \frac{P(z)C(z; \theta)}{1 + P(z)C(z; \theta)} - M(z) \right) W(z) \right|_2^2 \\
                       &= \left| \left( T(z) - M(z) \right) W(z) \right|_2^2
    \end{aligned}

which is equivalent to minimising the difference between the closed loop system scaled by an appropriate weighting function. The choice of :math:`W(z)` is up to the system designer and can be chosen to emphasize of deempasize performance in certain frequency bands. 

FIGURE: simple control loop + Model Reference

An optimal choice of :math:`C(z; \theta)` will produce a closed loop system whose transfer function is :math:`M(z)`. Thus, if the closed-loop system is fed a reference signal :math:`r(t)` its output will be :

.. math:: 

    y(t) = T(z)r(t) = M(z)r(t)

The VRFT method works by using the measured output (:math:`y(t)`) to generate a reference signal :math:`\bar{r}(t)` such that: 

.. math::

    M(z)\bar{r}(t) = y(t)

This is out so called *virtual* reference, it does not exist and is only used a tool to generate the optimal controller. The input of this controller is: 

.. math:: 

    e(t) = \bar{r}(t) - y(t)

The optimal controller must be such that when fed the virtual reference it produces the measured input (:math:`u(t)`). Thus: 

.. math::

    u(t) = C(z; \bar{\theta}) \bar{r}(t)

Where :math:`\bar{\theta}` is the optimal parameter vector. 

To calculate the optimal parameter vector we can start by attempting to solve a slightly easier problem. Consider the following performance index: 

TODO: Expand the calculations from the black book results

.. math::

    \begin{aligned}
        J^N_{VR}(\theta) &= \frac{1}{N} \sum_{t=1}^{N} \left( u(t) - C(z; \theta e(t) \right)^2
                         &= \frac{1}{N} \sum_{t=1}^{N}\left( u(t) - C(z; \phi(t) \theta \right)^2
    \end{aligned}

Since this equation is quadratic in :math:`\theta` the optimal value :math:`\hat{\theta}_N` is an explicit function of the data: 

.. math:: 

    \hat{\theta}_N = \left[ \sum_t \phi(t) \phi(t)^T \right]^{-1} \sum_t \phi(t)u(t)

However, we still haven't solved the original problem of minimising :math:`J_{MR}`. This method though is useful beacuse it is based purely on the data and is relatively easy to compute. 

In order to make :math:`J_{MR}` and :math:`J_{VR}` converge we introduce a pre-filter :math:`L(z)` for the data which results in: 

.. math:: 

    u_L(t) = L(z)U(t) \qquad , \qquad y_L(t) = L(z)Y(t)


TODO: choice of the prefilter from black book


Dealing with Noisy Data
***********************
TODO

