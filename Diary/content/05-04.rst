
Back from hiatus
================

:date: 2016-05-04

When I left off ages ago I had just discovered that one crucial figure had a mistake: the controllers in the figure were switched. The PD controller should in fact be in the inner loop and the PID in the outer loop. This and a couple of other changes made the data look better but I remember some graphs being very weird. 

We'll see how it goes today ...

The thesis specifies: 

- :math:`R_1` on the inner loop
- :math:`R_2` on the outer loop
  
It also gives:

- :math:`R_1` as a PID controller
- :math:`R_2` as a PD controller
  
To figure this out we can put  each of the controllers in the inner loop and look at their settling times. 

#. Using R1: :math:`T_a \approx 5s`
#. Using R2: :math:`T_a \approx 0.01s`
   
Clearly :math:`R_2` is significantly faster and intuitively would fit better in the inner loop. However that is not the case. 

Lets look at the entire system :

#. Using Inner R1, Outer R2: :math:`T_a \approx 25s`, non oscillating.
#. Using Inner R2, Outer R1: :math:`T_a \approx 180s`, very under-damped. 
   
This conclusively shows that R2 belongs in the outer loop and R1 in the inner loop. 

Graphs and code can be found `here <{filename}static/05-04/r1-or-r2_mlx.html>`_.

Now I just have to figure out why the output from matlab and simulink are different ...

If I flip the controllers in simulink and put R2 back on the outer loop then the values for :math:`q` line up. Why ?

First clue: In  the mlx script R1 and R2 were still hard-coded in a bunch of places. After replacing those things are starting to look better. 

In simulink the :math:`\Theta` and :math:`q` signals look good. The :math:`\delta M` signal however does not. 

In matlab the :math:`\Theta` signal is still good however the :math:`q` signal is wrong. 

All signals however fall short of their real counterparts. The system is still too slow compared to what is shown in the graphs in the thesis. I must have fucked up a calculation somewhere. I don't know where I fucked up but simply using ``OuterLoop.Li`` instead of calculating the loop tf manually was enough to get rid of that mistake. Maybe I forgot the integrator or something like that.

The weird thing here is that even though the :math:`\Theta` control loop is slow the :math:`q` variable looks fine but :math:`\delta M` does not. I'm really not sure what is going on. For today I'll pretend that everything is Ok and implement the VRFT.

Onto VRFT
---------

Things aren't going well. The complementary sensitivity for the inner loop comes out unstable, the pid params are completely off. I think I'm going to accept that my brain is fried for today and co home.



